const express = require("express");
const router = express.Router();
const jwt = require("jsonwebtoken");
const crypto = require("crypto");
const emailService = require("../utils/emailService");
const UserService = require("../database/userService");

// Helper function to get interval in milliseconds based on user selection
function getIntervalMs(intervalValue) {
  switch (intervalValue) {
    case "1-minute":
      return 1 * 60 * 1000; // 1 minute (testing)
    case "2-hours":
      return 2 * 60 * 60 * 1000; // 2 hours
    case "2-days":
      return 2 * 24 * 60 * 60 * 1000; // 2 days
    case "2-weeks":
      return 2 * 7 * 24 * 60 * 60 * 1000; // 2 weeks
    default:
      return 2 * 60 * 60 * 1000; // Default to 2 hours
  }
}

// Helper function to get inactivity period in milliseconds based on user selection
function getInactivityMs(periodValue) {
  switch (periodValue) {
    case "3-minutes":
      return 3 * 60 * 1000; // 3 minutes (testing)
    case "1-day":
      return 24 * 60 * 60 * 1000; // 1 day
    case "1-month":
      return 30 * 24 * 60 * 60 * 1000; // 1 month (30 days)
    case "3-months":
      return 3 * 30 * 24 * 60 * 60 * 1000; // 3 months
    case "6-months":
      return 6 * 30 * 24 * 60 * 60 * 1000; // 6 months
    case "9-months":
      return 9 * 30 * 24 * 60 * 60 * 1000; // 9 months
    default:
      return 24 * 60 * 60 * 1000; // Default to 1 day
  }
}

// Initialize database service
const userService = new UserService();

// Initialize database connection
userService.connect().catch(console.error);

// In-memory cache for active sessions (will be replaced by database queries)
const activeDeadmanSwitches = new Map();
const checkinTokens = new Map();

// Middleware to verify JWT token and load user data
const authenticateToken = async (req, res, next) => {
  // Try to get token from HTTP-only cookie first, then fallback to Authorization header
  const token =
    req.cookies.token ||
    (req.headers["authorization"] &&
      req.headers["authorization"].split(" ")[1]);

  if (token == null) return res.sendStatus(401);

  jwt.verify(token, process.env.SECRET_KEY, async (err, user) => {
    if (err) return res.sendStatus(403);

    try {
      // Get user data from database
      const userData = await userService.getUserById(user.userId);
      if (!userData) {
        return res.sendStatus(403);
      }

      req.user = {
        ...user,
        userData,
      };
      next();
    } catch (error) {
      console.error("Error loading user data:", error);
      return res.sendStatus(500);
    }
  });
};

// Simple test route
router.get("/test", (req, res) => {
  res.json({ message: "Minimal deadman routes working!" });
});

// User signup endpoint (encrypted database)
router.post("/signup", async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({ message: "Email and password required" });
    }

    // Create new user with encrypted data
    const userData = await userService.createUser(email, password, {
      emails: [],
      settings: {},
      checkinTokens: {},
    });

    // Generate JWT token
    const token = jwt.sign(
      { userId: userData.userId, email: userData.email },
      process.env.SECRET_KEY,
      { expiresIn: "24h" },
    );

    // Log audit event
    await userService.logAudit(
      userData.userId,
      "USER_SIGNUP",
      "User account created",
      req.ip,
      req.get("User-Agent"),
    );

    // Set HTTP-only cookie instead of sending token in response
    res.cookie("token", token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "strict",
      maxAge: 24 * 60 * 60 * 1000, // 24 hours
    });

    res.status(201).json({
      success: true,
      message: "User created successfully",
      user: {
        id: userData.userId,
        email: userData.email,
      },
    });
  } catch (error) {
    console.error("Error creating user:", error);

    if (error.message === "User already exists") {
      return res.status(409).json({ message: "User already exists" });
    }

    res.status(500).json({ message: "Failed to create user" });
  }
});

// User logout endpoint
router.post("/logout", (req, res) => {
  // Clear the HTTP-only cookie
  res.clearCookie("token", {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
  });

  res.json({
    success: true,
    message: "Logged out successfully",
  });
});

// User login endpoint (encrypted database)
router.post("/login", async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({ message: "Email and password required" });
    }

    // Authenticate user and get decrypted data
    const userData = await userService.authenticateUser(email, password);

    // Generate JWT token
    const token = jwt.sign(
      { userId: userData.userId, email: userData.email },
      process.env.SECRET_KEY,
      { expiresIn: "24h" },
    );

    // Log audit event
    await userService.logAudit(
      userData.userId,
      "USER_LOGIN",
      "User logged in",
      req.ip,
      req.get("User-Agent"),
    );

    // Set HTTP-only cookie instead of sending token in response
    res.cookie("token", token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "strict",
      maxAge: 24 * 60 * 60 * 1000, // 24 hours
    });

    res.json({
      success: true,
      message: "Login successful",
      user: {
        id: userData.userId,
        email: userData.email,
        lastLogin: userData.lastLogin,
      },
    });
  } catch (error) {
    console.error("Error authenticating user:", error);

    if (error.message === "Invalid credentials") {
      return res.status(401).json({ message: "Invalid email or password" });
    }

    res.status(500).json({ message: "Authentication failed" });
  }
});

// Legacy in-memory storage (being phased out for encrypted database)
const userEmails = new Map();
const deadmanActivationHistory = new Map();

// Emails endpoint - save/update email data (encrypted database)
router.post("/emails", authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    const userEmail = req.user.email;
    const { emailAddress, emailContent, emailIndex } = req.body;

    // Get password from request (needed for decryption)
    const password = req.body.password;
    if (!password) {
      return res
        .status(400)
        .json({ message: "Password required for encryption" });
    }

    // Get user's salt and current encrypted data
    const user = await userService.getUserById(userId);
    const currentData = await userService.getUserData(
      userId,
      password,
      user.salt,
    );

    let existingEmails = currentData.emails || [];

    if (emailIndex !== null && emailIndex >= 0) {
      // Update existing email
      existingEmails[emailIndex] = {
        address: emailAddress,
        content: emailContent,
        to: emailAddress,
        subject: "Important Message from " + userEmail,
        body: emailContent,
      };
    } else {
      // Add new email
      existingEmails.push({
        address: emailAddress,
        content: emailContent,
        to: emailAddress,
        subject: "Important Message from " + userEmail,
        body: emailContent,
      });
    }

    // Update encrypted database
    await userService.updateUserData(userId, password, user.salt, {
      emails: existingEmails,
      settings: currentData.settings,
      checkinTokens: currentData.checkinTokens,
    });

    // Log audit event
    await userService.logAudit(
      userId,
      emailIndex !== null ? "EMAIL_UPDATED" : "EMAIL_ADDED",
      `Email ${emailIndex !== null ? "updated" : "added"}: ${emailAddress}`,
      req.ip,
      req.get("User-Agent"),
    );

    res.json({
      success: true,
      message: "Email saved successfully",
      emailCount: existingEmails.length,
    });
  } catch (error) {
    console.error("Error saving email:", error);
    res.status(500).json({ message: "Failed to save email" });
  }
});

// Get emails endpoint (encrypted database)
router.get("/emails", authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;

    // Get password from query params or body (needed for decryption)
    const password = req.query.password || req.body.password;
    if (!password) {
      return res
        .status(400)
        .json({ message: "Password required for decryption" });
    }

    // Get user's salt and decrypt data
    const user = await userService.getUserById(userId);
    const userData = await userService.getUserData(userId, password, user.salt);

    const emails = userData.emails || [];

    res.json({
      success: true,
      emails: emails,
      syncInfo: {
        backendCount: emails.length,
        encrypted: true,
        needsSync: false,
      },
    });
  } catch (error) {
    console.error("Error getting emails:", error);
    res.status(500).json({ message: "Failed to get emails" });
  }
});

// Delete email by index (encrypted database)
router.delete("/emails/:index", authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    const emailIndex = parseInt(req.params.index);

    // Get password from request body (needed for decryption)
    const password = req.body.password;
    if (!password) {
      return res
        .status(400)
        .json({ message: "Password required for encryption" });
    }

    // Validate email index
    if (isNaN(emailIndex) || emailIndex < 0) {
      return res.status(400).json({ message: "Invalid email index" });
    }

    // Get user's salt and current encrypted data
    const user = await userService.getUserById(userId);
    const currentData = await userService.getUserData(
      userId,
      password,
      user.salt,
    );

    let existingEmails = currentData.emails || [];

    // Check if email index exists
    if (emailIndex >= existingEmails.length) {
      return res.status(404).json({ message: "Email not found" });
    }

    // Remove email at specified index
    existingEmails.splice(emailIndex, 1);

    // Update encrypted database
    await userService.updateUserData(userId, password, user.salt, {
      emails: existingEmails,
      settings: currentData.settings,
      checkinTokens: currentData.checkinTokens,
    });

    // Log audit event
    await userService.logAudit(
      userId,
      "EMAIL_DELETED",
      `Email deleted at index ${emailIndex}`,
      req.ip,
    );

    res.json({
      message: "Email deleted successfully",
      remainingCount: existingEmails.length,
    });
  } catch (error) {
    console.error("Error deleting email:", error);
    res.status(500).json({ message: "Failed to delete email" });
  }
});

// Status endpoint to check if user is authenticated
router.get("/status", authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    const user = await userService.getUserById(userId);

    res.json({
      success: true,
      authenticated: true,
      user: {
        id: userId,
        email: user.email,
      },
    });
  } catch (error) {
    console.error("Error getting user status:", error);
    res.status(500).json({ message: "Failed to get user status" });
  }
});

// Timer status endpoint for countdown synchronization
router.get("/timer-status", authenticateToken, async (req, res) => {
  try {
    const userEmail = req.user.email;
    console.log(`🔍 TIMER-STATUS: Request from ${userEmail}`);

    // Check if deadman switch is active for this user
    if (activeDeadmanSwitches.has(userEmail)) {
      const switchData = activeDeadmanSwitches.get(userEmail);
      const now = Date.now();

      console.log(`📊 TIMER-STATUS: Active switch found for ${userEmail}`);
      console.log(`   - Current time: ${now}`);
      console.log(`   - Next checkin: ${switchData.nextCheckin}`);
      console.log(`   - Deadman activation: ${switchData.deadmanActivation}`);
      console.log(`   - Last activity: ${switchData.lastActivity}`);
      console.log(
        `   - Time until next checkin: ${switchData.nextCheckin - now}ms`,
      );
      console.log(
        `   - Time until deadman: ${switchData.deadmanActivation - now}ms`,
      );

      res.json({
        success: true,
        active: true,
        lastActivity: switchData.lastActivity,
        nextCheckin: switchData.nextCheckin,
        deadmanActivation: switchData.deadmanActivation,
        settings: {
          checkinInterval: switchData.checkinInterval,
          inactivityPeriod: switchData.inactivityPeriod,
        },
      });
    } else {
      console.log(`❌ TIMER-STATUS: No active switch for ${userEmail}`);
      res.json({
        success: true,
        active: false,
      });
    }
  } catch (error) {
    console.error("Error getting timer status:", error);
    res.status(500).json({ message: "Failed to get timer status" });
  }
});

// Deadman status endpoint for checking if deadman was triggered
router.get("/deadman-status", authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;

    // Check if deadman switch was triggered (would have been removed from activeDeadmanSwitches)
    const history = deadmanActivationHistory.get(userId);

    if (history && history.triggered) {
      res.json({
        success: true,
        triggered: true,
        triggeredAt: history.triggeredAt,
        emailsSent: history.emailsSent,
      });
    } else {
      res.json({
        success: true,
        triggered: false,
      });
    }
  } catch (error) {
    console.error("Error getting deadman status:", error);
    res.status(500).json({ message: "Failed to get deadman status" });
  }
});

// Activate deadman switch (encrypted database)
router.post("/activate", authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    const userEmail = req.user.email;
    const { checkinMethod, checkinInterval, inactivityPeriod, password } =
      req.body;

    // Password required for encryption/decryption
    if (!password) {
      return res
        .status(400)
        .json({ message: "Password required for encryption" });
    }

    // Get user's salt and current encrypted data
    const user = await userService.getUserById(userId);
    const userData = await userService.getUserData(userId, password, user.salt);
    const emails = userData.emails || [];

    // Calculate timer intervals
    const checkinIntervalMs = getIntervalMs(checkinInterval);
    const inactivityMs = getInactivityMs(inactivityPeriod);

    // Create encrypted deadman session in database
    const sessionData = await userService.createDeadmanSession(userId, {
      checkinInterval: checkinIntervalMs,
      inactivityTimeout: inactivityMs,
    });

    // Store settings in encrypted user data
    const updatedSettings = {
      checkinMethod,
      checkinInterval,
      inactivityPeriod,
      sessionToken: sessionData.sessionToken,
    };

    await userService.updateUserData(userId, password, user.salt, {
      emails: emails,
      settings: updatedSettings,
      checkinTokens: userData.checkinTokens || {},
    });

    // Store the deadman switch data in memory for active timers
    const now = Date.now();
    const switchData = {
      userEmail,
      userId,
      sessionToken: sessionData.sessionToken,
      settings: {
        checkinMethod,
        checkinInterval,
        inactivityPeriod,
        emails,
      },
      lastActivity: new Date(),
      nextCheckin: now + checkinIntervalMs,
      deadmanActivation: now + inactivityMs,
      checkinTimer: null,
      deadmanTimer: null,
    };

    // Set up check-in timer
    switchData.checkinTimer = setInterval(async () => {
      try {
        // Generate unique check-in token
        const checkinToken = crypto.randomBytes(32).toString("hex");
        checkinTokens.set(checkinToken, userEmail);

        // Update session activity in database
        if (sessionData && sessionData.sessionToken) {
          try {
            await userService.updateSessionActivity(sessionData.sessionToken);
          } catch (error) {
            console.error(
              `Failed to update session activity during periodic check-in:`,
              error,
            );
          }
        }

        // CRITICAL: Reset deadman timer when sending check-in email
        if (switchData.deadmanTimer) {
          clearTimeout(switchData.deadmanTimer);
        }

        // Recreate deadman timer with full inactivity period
        const inactivityMs = getInactivityMs(
          switchData.settings.inactivityPeriod,
        );
        switchData.deadmanTimer = setTimeout(async () => {
          try {
            // Get emails from both memory and switchData (fallback)
            let emails = userEmails.get(userEmail) || [];
            if (emails.length === 0 && switchData.settings.emails) {
              emails = switchData.settings.emails;
              console.log(
                `Using fallback emails from switchData for ${userEmail}: ${emails.length} emails`,
              );
            }

            console.log(
              `Deadman timer expired for ${userEmail}, sending ${emails.length} emails`,
            );

            // Record activation immediately (before email sending)
            deadmanActivationHistory.set(userEmail, {
              triggered: true,
              timestamp: new Date().toISOString(),
              emailsSent: emails.length,
              reason: "inactivity_timeout",
              status: "pending",
            });

            if (emails.length === 0) {
              console.error(
                `No emails configured for deadman activation for ${userEmail}`,
              );
              deadmanActivationHistory.set(userEmail, {
                triggered: true,
                timestamp: new Date().toISOString(),
                emailsSent: 0,
                reason: "inactivity_timeout",
                status: "no_emails_configured",
              });
            } else {
              emailService
                .sendDeadmanEmails(userEmail, emails)
                .then((emailsSent) => {
                  if (!emailsSent) {
                    console.error(
                      `Failed to send deadman emails for ${userEmail}`,
                    );
                    deadmanActivationHistory.set(userEmail, {
                      triggered: true,
                      timestamp: new Date().toISOString(),
                      emailsSent: 0,
                      reason: "inactivity_timeout",
                      status: "email_failed",
                    });
                  } else {
                    console.log(
                      `Successfully sent deadman emails for ${userEmail}`,
                    );
                    deadmanActivationHistory.set(userEmail, {
                      triggered: true,
                      timestamp: new Date().toISOString(),
                      emailsSent: emails.length,
                      reason: "inactivity_timeout",
                      status: "success",
                    });
                  }
                })
                .catch((error) => {
                  console.error(
                    `Error sending deadman emails for ${userEmail}:`,
                    error,
                  );
                  deadmanActivationHistory.set(userEmail, {
                    triggered: true,
                    timestamp: new Date().toISOString(),
                    emailsSent: 0,
                    reason: "inactivity_timeout",
                    status: "error",
                    error: error.message,
                  });
                });
            }

            // Clean up after activation
            const currentSwitchData = activeDeadmanSwitches.get(userEmail);
            if (currentSwitchData && currentSwitchData.checkinTimer) {
              clearInterval(currentSwitchData.checkinTimer);
            }

            // Clear all user data after deadman activation
            userEmails.delete(userEmail);

            // Clear any check-in tokens for this user
            const tokensToDelete = [];
            for (const [token, email] of checkinTokens.entries()) {
              if (email === userEmail) {
                tokensToDelete.push(token);
              }
            }
            tokensToDelete.forEach((token) => checkinTokens.delete(token));

            activeDeadmanSwitches.delete(userEmail);
          } catch (error) {
            console.error(`Error in deadman timer callback:`, error);
          }
        }, inactivityMs);

        // Send actual check-in email (non-blocking)
        emailService
          .sendCheckinEmail(userEmail, checkinToken)
          .then((emailSent) => {
            if (!emailSent) {
              console.error(`Failed to send check-in email to ${userEmail}`);
            }
          })
          .catch((error) => {
            console.error(
              `Error sending check-in email to ${userEmail}:`,
              error,
            );
          });

        // Update next check-in time
        const nextCheckinNow = Date.now();
        switchData.nextCheckinTime = new Date(
          nextCheckinNow + checkinIntervalMs,
        );
        switchData.nextCheckin = nextCheckinNow + checkinIntervalMs;
        // Deadman activation time should NOT be reset here
        console.log(
          `📧 PERIODIC CHECK-IN: Email sent for ${userEmail}, check-in email sent - deadman timer NOT reset (${inactivityMs / 1000 / 60} minutes)`,
        );
      } catch (error) {
        console.error(`Error in check-in timer callback:`, error);
      }
    }, checkinIntervalMs);

    // Set up deadman timer
    console.log(
      `⏰ CREATING deadman timer for ${userEmail} - will fire in ${inactivityMs}ms (${inactivityMs / 1000 / 60} minutes)`,
    );
    console.log(
      `⏰ Deadman timer will fire at timestamp: ${Date.now() + inactivityMs}`,
    );
    switchData.deadmanTimer = setTimeout(async () => {
      try {
        console.log(`🚨 DEADMAN TIMER EXPIRED for ${userEmail}`);

        // Get emails from both memory and switchData (fallback)
        let deadmanEmails = userEmails.get(userEmail) || [];
        if (deadmanEmails.length === 0 && switchData.settings.emails) {
          deadmanEmails = switchData.settings.emails;
          console.log(
            `Using fallback emails from switchData for ${userEmail}: ${deadmanEmails.length} emails`,
          );
        }

        console.log(
          `Deadman timer expired for ${userEmail}, sending ${deadmanEmails.length} emails`,
        );

        // Clear check-in timer FIRST to stop further check-in emails
        const currentSwitchData = activeDeadmanSwitches.get(userEmail);
        if (currentSwitchData && currentSwitchData.checkinTimer) {
          clearInterval(currentSwitchData.checkinTimer);
          console.log(`🛑 STOPPED check-in timer for ${userEmail}`);
        }

        // Record activation immediately (before email sending)
        deadmanActivationHistory.set(userEmail, {
          triggered: true,
          timestamp: new Date().toISOString(),
          emailsSent: deadmanEmails.length,
          reason: "inactivity_timeout",
          status: "pending",
        });

        if (deadmanEmails.length === 0) {
          console.error(
            `❌ No emails configured for deadman activation for ${userEmail}`,
          );
          deadmanActivationHistory.set(userEmail, {
            triggered: true,
            timestamp: new Date().toISOString(),
            emailsSent: 0,
            reason: "inactivity_timeout",
            status: "no_emails_configured",
          });
        } else {
          // Send deadman emails
          console.log(
            `📧 Sending ${deadmanEmails.length} deadman emails for ${userEmail}`,
          );
          emailService
            .sendDeadmanEmails(userEmail, deadmanEmails)
            .then((emailsSent) => {
              if (!emailsSent) {
                console.error(
                  `❌ Failed to send deadman emails for ${userEmail}`,
                );
                deadmanActivationHistory.set(userEmail, {
                  triggered: true,
                  timestamp: new Date().toISOString(),
                  emailsSent: 0,
                  reason: "inactivity_timeout",
                  status: "email_failed",
                });
              } else {
                console.log(
                  `✅ Successfully sent deadman emails for ${userEmail}`,
                );
                deadmanActivationHistory.set(userEmail, {
                  triggered: true,
                  timestamp: new Date().toISOString(),
                  emailsSent: deadmanEmails.length,
                  reason: "inactivity_timeout",
                  status: "success",
                });
              }
            })
            .catch((error) => {
              console.error(
                `❌ Error sending deadman emails for ${userEmail}:`,
                error,
              );
              deadmanActivationHistory.set(userEmail, {
                triggered: true,
                timestamp: new Date().toISOString(),
                emailsSent: 0,
                reason: "inactivity_timeout",
                status: "error",
                error: error.message,
              });
            });
        }

        // Clean up all user data after deadman activation
        userEmails.delete(userEmail);

        // Clear any check-in tokens for this user
        const tokensToDelete = [];
        for (const [token, email] of checkinTokens.entries()) {
          if (email === userEmail) {
            tokensToDelete.push(token);
          }
        }
        tokensToDelete.forEach((token) => checkinTokens.delete(token));

        // Remove the active switch
        activeDeadmanSwitches.delete(userEmail);
        console.log(
          `🧹 Cleaned up all data for ${userEmail} after deadman activation`,
        );
      } catch (error) {
        console.error(
          `❌ Error in deadman timer callback for ${userEmail}:`,
          error,
        );
      }
    }, inactivityMs);

    console.log(`✅ Deadman timer created successfully for ${userEmail}`);
    console.log(`   Timer ID: ${switchData.deadmanTimer}`);
    console.log(
      `   Will expire at: ${new Date(Date.now() + inactivityMs).toLocaleString()}`,
    );

    // Store the active switch
    activeDeadmanSwitches.set(userEmail, switchData);

    res.status(200).json({
      success: true,
      message: "Deadman switch activated successfully",
      settings: {
        checkinIntervalMinutes: checkinIntervalMs / 1000 / 60,
        deadmanTimerMinutes: inactivityMs / 1000 / 60,
      },
    });
  } catch (error) {
    console.error("Error activating deadman switch:", error);
    res.status(500).json({ message: "Failed to activate deadman switch" });
  }
});

// Deactivate deadman switch
router.post("/deactivate", authenticateToken, (req, res) => {
  try {
    const userEmail = req.user.email;

    if (!activeDeadmanSwitches.has(userEmail)) {
      return res.status(400).json({
        message: "No active deadman switch found for this user",
      });
    }

    // Get the active switch data
    const switchData = activeDeadmanSwitches.get(userEmail);

    // Clear all timers
    if (switchData.checkinTimer) clearInterval(switchData.checkinTimer);
    if (switchData.deadmanTimer) clearTimeout(switchData.deadmanTimer);

    // Remove from active switches
    activeDeadmanSwitches.delete(userEmail);

    res.status(200).json({
      success: true,
      message: "Deadman switch deactivated successfully",
    });
  } catch (error) {
    console.error("Error deactivating deadman switch:", error);
    res.status(500).json({ message: "Failed to deactivate deadman switch" });
  }
});

// Activity logging endpoint
router.post("/activity", authenticateToken, (req, res) => {
  try {
    const userEmail = req.user.email;
    res.status(200).json({
      success: true,
      message: "Activity logged successfully",
    });
  } catch (error) {
    console.error("Error logging activity:", error);
    res.status(500).json({ message: "Failed to log activity" });
  }
});

// Timer status endpoint - returns real backend timer values
// Removed duplicate timer-status endpoint - using the first one that returns absolute timestamps

// New endpoint to check if deadman was triggered for user
router.get("/deadman-status", authenticateToken, (req, res) => {
  try {
    const userEmail = req.user.email;

    // Check activation history first (most reliable)
    const activationHistory = deadmanActivationHistory.get(userEmail);
    if (activationHistory && activationHistory.triggered) {
      return res.json({
        triggered: true,
        message:
          "Deadman switch has been activated - beneficiary emails were sent",
        canReset: true,
        activationTime: activationHistory.timestamp,
        emailsSent: activationHistory.emailsSent,
      });
    }

    // Check if user has an active deadman switch
    const hasActiveSwitch = activeDeadmanSwitches.has(userEmail);
    if (hasActiveSwitch) {
      return res.json({
        triggered: false,
        message: "Deadman switch is active and running",
        canReset: false,
      });
    }

    // No active switch and no activation history = never activated
    res.json({
      triggered: false,
      message: "No deadman switch configured",
      canReset: false,
    });
  } catch (error) {
    console.error("Error checking deadman status:", error);
    res.status(500).json({ message: "Failed to check deadman status" });
  }
});

// Debug endpoint to check backend state
router.get("/debug/status", (req, res) => {
  const switches = [];
  for (const [userEmail, switchData] of activeDeadmanSwitches.entries()) {
    switches.push({
      userEmail,
      lastActivity: switchData.lastActivity,
      hasCheckinTimer: !!switchData.checkinTimer,
      hasDeadmanTimer: !!switchData.deadmanTimer,
      settings: switchData.settings,
    });
  }

  res.json({
    activeDeadmanSwitches: switches,
    userEmailsCount: userEmails.size,
    checkinTokensCount: checkinTokens.size,
    timestamp: new Date().toISOString(),
  });
});

// Email test endpoint
router.post("/debug/test-email", authenticateToken, async (req, res) => {
  try {
    const userEmail = req.user.email;

    // Test email service connection
    const connectionTest = await emailService.testEmailConnection();

    if (!connectionTest.success) {
      return res.json({
        success: false,
        message: "Email service connection failed",
        error: connectionTest.message,
      });
    }

    // Test sending a check-in email
    const testToken = "test-token-123";
    const emailSent = await emailService.sendCheckinEmail(userEmail, testToken);

    res.json({
      success: emailSent,
      message: emailSent
        ? "Test email sent successfully"
        : "Failed to send test email",
      connectionTest: connectionTest,
    });
  } catch (error) {
    console.error("Email test error:", error);
    res.status(500).json({
      success: false,
      message: "Email test failed",
      error: error.message,
    });
  }
});

// Reset endpoint to clear deadman data after activation
router.post("/reset", authenticateToken, (req, res) => {
  try {
    const userEmail = req.user.email;

    // Clear any active deadman switch
    if (activeDeadmanSwitches.has(userEmail)) {
      const switchData = activeDeadmanSwitches.get(userEmail);
      if (switchData.checkinTimer) clearInterval(switchData.checkinTimer);
      if (switchData.deadmanTimer) clearTimeout(switchData.deadmanTimer);
      activeDeadmanSwitches.delete(userEmail);
    }

    // Clear stored emails
    if (userEmails.has(userEmail)) {
      userEmails.delete(userEmail);
    }

    // Clear activation history
    if (deadmanActivationHistory.has(userEmail)) {
      deadmanActivationHistory.delete(userEmail);
    }

    // Clear any check-in tokens for this user
    const tokensToDelete = [];
    for (const [token, email] of checkinTokens.entries()) {
      if (email === userEmail) {
        tokensToDelete.push(token);
      }
    }
    tokensToDelete.forEach((token) => checkinTokens.delete(token));

    res.json({
      success: true,
      message: "Deadman switch data has been reset successfully",
      cleared: {
        activeSwitch: true,
        emails: true,
        activationHistory: true,
        tokens: tokensToDelete.length,
      },
    });
  } catch (error) {
    console.error("Error resetting deadman data:", error);
    res.status(500).json({
      message: "Failed to reset deadman data",
      error: error.message,
    });
  }
});

// Check-in endpoint - handles check-in link clicks
router.get("/checkin/:token", async (req, res) => {
  try {
    const { token } = req.params;

    if (!checkinTokens.has(token)) {
      return res.status(400).send(`
        <html>
          <body style="font-family: Arial, sans-serif; text-align: center; padding: 50px;">
            <h2>❌ Invalid Check-In Link</h2>
            <p>This check-in link is invalid or has expired.</p>
            <p>Please use the latest check-in email.</p>
          </body>
        </html>
      `);
    }

    const userEmail = checkinTokens.get(token);

    // Update activity time and reset both timers
    if (activeDeadmanSwitches.has(userEmail)) {
      const switchData = activeDeadmanSwitches.get(userEmail);
      switchData.lastActivity = new Date();

      // Update session activity in database if session token exists
      if (switchData.sessionToken) {
        try {
          await userService.updateSessionActivity(switchData.sessionToken);
          console.log(
            `✅ CHECK-IN BUTTON CLICKED: Database session activity updated for ${userEmail}`,
          );
        } catch (error) {
          console.error(
            `Failed to update session activity for ${userEmail}:`,
            error,
          );
        }
      }

      // Reset check-in timer
      if (switchData.checkinTimer) {
        clearInterval(switchData.checkinTimer);
        console.log(
          `🔄 CHECK-IN BUTTON: Cleared existing check-in timer for ${userEmail}`,
        );
      }

      // Reset deadman timer
      if (switchData.deadmanTimer) {
        clearTimeout(switchData.deadmanTimer);
        console.log(
          `🔄 CHECK-IN BUTTON: Cleared existing deadman timer for ${userEmail}`,
        );
      } else {
        console.log(
          `⚠️ CHECK-IN BUTTON: No deadman timer to clear for ${userEmail}`,
        );
      }

      // Recreate check-in timer
      const checkinIntervalMs = getIntervalMs(
        switchData.settings.checkinInterval,
      );
      const now = Date.now();
      switchData.nextCheckinTime = new Date(now + checkinIntervalMs);
      switchData.nextCheckin = now + checkinIntervalMs;
      console.log(
        `⏰ CHECK-IN BUTTON: Created new check-in timer for ${userEmail} (${checkinIntervalMs / 1000 / 60} minutes)`,
      );
      switchData.checkinTimer = setInterval(async () => {
        try {
          const checkinToken = crypto.randomBytes(32).toString("hex");
          checkinTokens.set(checkinToken, userEmail);

          // Update session activity in database during periodic check-ins
          if (switchData.sessionToken) {
            try {
              await userService.updateSessionActivity(switchData.sessionToken);
            } catch (error) {
              console.error(
                `Failed to update session activity during periodic check-in for ${userEmail}:`,
                error,
              );
            }
          }

          // CRITICAL: Reset deadman timer when sending check-in email
          if (switchData.deadmanTimer) {
            clearTimeout(switchData.deadmanTimer);
          }

          // Recreate deadman timer with full inactivity period
          const inactivityMs = getInactivityMs(
            switchData.settings.inactivityPeriod,
          );
          switchData.deadmanTimer = setTimeout(async () => {
            try {
              // Get emails from both memory and switchData (fallback)
              let emails = userEmails.get(userEmail) || [];
              if (emails.length === 0 && switchData.settings.emails) {
                emails = switchData.settings.emails;
                console.log(
                  `Using fallback emails from switchData for ${userEmail}: ${emails.length} emails`,
                );
              }

              console.log(
                `Deadman timer expired for ${userEmail}, sending ${emails.length} emails`,
              );

              // Record activation immediately (before email sending)
              deadmanActivationHistory.set(userEmail, {
                triggered: true,
                timestamp: new Date().toISOString(),
                emailsSent: emails.length,
                reason: "inactivity_timeout",
                status: "pending",
              });

              if (emails.length === 0) {
                console.error(
                  `No emails configured for deadman activation for ${userEmail}`,
                );
                deadmanActivationHistory.set(userEmail, {
                  triggered: true,
                  timestamp: new Date().toISOString(),
                  emailsSent: 0,
                  reason: "inactivity_timeout",
                  status: "no_emails_configured",
                });
              } else {
                emailService
                  .sendDeadmanEmails(userEmail, emails)
                  .then((emailsSent) => {
                    if (!emailsSent) {
                      console.error(
                        `Failed to send deadman emails for ${userEmail}`,
                      );
                      deadmanActivationHistory.set(userEmail, {
                        triggered: true,
                        timestamp: new Date().toISOString(),
                        emailsSent: 0,
                        reason: "inactivity_timeout",
                        status: "email_failed",
                      });
                    } else {
                      console.log(
                        `Successfully sent deadman emails for ${userEmail}`,
                      );
                      deadmanActivationHistory.set(userEmail, {
                        triggered: true,
                        timestamp: new Date().toISOString(),
                        emailsSent: emails.length,
                        reason: "inactivity_timeout",
                        status: "success",
                      });
                    }
                  })
                  .catch((error) => {
                    console.error(
                      `Error sending deadman emails for ${userEmail}:`,
                      error,
                    );
                    deadmanActivationHistory.set(userEmail, {
                      triggered: true,
                      timestamp: new Date().toISOString(),
                      emailsSent: 0,
                      reason: "inactivity_timeout",
                      status: "error",
                      error: error.message,
                    });
                  });
              }

              // Clean up after activation
              const currentSwitchData = activeDeadmanSwitches.get(userEmail);
              if (currentSwitchData && currentSwitchData.checkinTimer) {
                clearInterval(currentSwitchData.checkinTimer);
              }

              // Clear all user data after deadman activation
              userEmails.delete(userEmail);

              // Clear any check-in tokens for this user
              const tokensToDelete = [];
              for (const [token, email] of checkinTokens.entries()) {
                if (email === userEmail) {
                  tokensToDelete.push(token);
                }
              }
              tokensToDelete.forEach((token) => checkinTokens.delete(token));

              activeDeadmanSwitches.delete(userEmail);
            } catch (error) {
              console.error(`Error in deadman timer callback:`, error);
            }
          }, inactivityMs);

          emailService
            .sendCheckinEmail(userEmail, checkinToken)
            .then((emailSent) => {
              if (!emailSent) {
                console.error(`Failed to send check-in email to ${userEmail}`);
              }
            })
            .catch((error) => {
              console.error(
                `Error sending check-in email to ${userEmail}:`,
                error,
              );
            });

          // Update next check-in time
          const nextCheckinNow = Date.now();
          switchData.nextCheckinTime = new Date(
            nextCheckinNow + checkinIntervalMs,
          );
          switchData.nextCheckin = nextCheckinNow + checkinIntervalMs;
          // Deadman activation time should NOT be reset here
          console.log(
            `📧 PERIODIC CHECK-IN: Email sent for ${userEmail}, check-in email sent - deadman timer NOT reset (${inactivityMs / 1000 / 60} minutes)`,
          );
        } catch (error) {
          console.error(`Error in check-in timer callback:`, error);
        }
      }, checkinIntervalMs);

      // Recreate deadman timer
      const inactivityMs = getInactivityMs(
        switchData.settings.inactivityPeriod,
      );
      switchData.deadmanActivation = now + inactivityMs;
      console.log(
        `⏰ CHECK-IN BUTTON: Created new deadman timer for ${userEmail} (${inactivityMs / 1000 / 60} minutes)`,
      );
      console.log(
        `🔍 DEBUG: CHECK-IN BUTTON deadman activation set to: ${switchData.deadmanActivation} (current time: ${now})`,
      );
      switchData.deadmanTimer = setTimeout(async () => {
        try {
          // Get emails from both memory and switchData (fallback)
          let emails = userEmails.get(userEmail) || [];
          if (emails.length === 0 && switchData.settings.emails) {
            emails = switchData.settings.emails;
            console.log(
              `Using fallback emails from switchData for ${userEmail}: ${emails.length} emails`,
            );
          }

          console.log(
            `Deadman timer expired for ${userEmail}, sending ${emails.length} emails`,
          );

          // Record activation immediately (before email sending)
          deadmanActivationHistory.set(userEmail, {
            triggered: true,
            timestamp: new Date().toISOString(),
            emailsSent: emails.length,
            reason: "inactivity_timeout",
            status: "pending",
          });

          if (emails.length === 0) {
            console.error(
              `No emails configured for deadman activation for ${userEmail}`,
            );
            deadmanActivationHistory.set(userEmail, {
              triggered: true,
              timestamp: new Date().toISOString(),
              emailsSent: 0,
              reason: "inactivity_timeout",
              status: "no_emails_configured",
            });
          } else {
            emailService
              .sendDeadmanEmails(userEmail, emails)
              .then((emailsSent) => {
                if (!emailsSent) {
                  console.error(
                    `Failed to send deadman emails for ${userEmail}`,
                  );
                  // Update activation history with failure status
                  deadmanActivationHistory.set(userEmail, {
                    triggered: true,
                    timestamp: new Date().toISOString(),
                    emailsSent: 0,
                    reason: "inactivity_timeout",
                    status: "email_failed",
                  });
                } else {
                  console.log(
                    `Successfully sent deadman emails for ${userEmail}`,
                  );
                  // Update activation history with success status
                  deadmanActivationHistory.set(userEmail, {
                    triggered: true,
                    timestamp: new Date().toISOString(),
                    emailsSent: emails.length,
                    reason: "inactivity_timeout",
                    status: "success",
                  });
                }
              })
              .catch((error) => {
                console.error(
                  `Error sending deadman emails for ${userEmail}:`,
                  error,
                );
                // Update activation history with error status
                deadmanActivationHistory.set(userEmail, {
                  triggered: true,
                  timestamp: new Date().toISOString(),
                  emailsSent: 0,
                  reason: "inactivity_timeout",
                  status: "error",
                  error: error.message,
                });
              });
          }

          // Clean up after activation (do cleanup immediately)
          // Clear check-in timer to stop further check-in emails
          const switchData = activeDeadmanSwitches.get(userEmail);
          if (switchData && switchData.checkinTimer) {
            clearInterval(switchData.checkinTimer);
          }

          // Clear all user data after deadman activation
          userEmails.delete(userEmail);

          // Clear any check-in tokens for this user
          const tokensToDelete = [];
          for (const [token, email] of checkinTokens.entries()) {
            if (email === userEmail) {
              tokensToDelete.push(token);
            }
          }
          tokensToDelete.forEach((token) => checkinTokens.delete(token));

          activeDeadmanSwitches.delete(userEmail);
        } catch (error) {
          console.error(`Error in deadman timer callback:`, error);
        }
      }, inactivityMs);
    }

    // Remove used token
    checkinTokens.delete(token);
    console.log(
      `🎯 CHECK-IN COMPLETE: Both timers successfully reset for ${userEmail}`,
    );

    // Send success response
    res.send(`
      <html>
        <body style="font-family: Arial, sans-serif; text-align: center; padding: 50px;">
          <h2>✅ Check-In Successful!</h2>
          <p>Thank you for checking in.</p>
          <p>Your deadman switch timer has been reset.</p>
          <p>Last activity: ${new Date().toLocaleString()}</p>
          <hr>
          <p><small>You can close this window now.</small></p>
        </body>
      </html>
    `);
  } catch (error) {
    console.error("Error processing check-in:", error);
    res.status(500).send(`
      <html>
        <body style="font-family: Arial, sans-serif; text-align: center; padding: 50px;">
          <h2>❌ Check-In Error</h2>
          <p>An error occurred while processing your check-in.</p>
          <p>Please try again or contact support.</p>
        </body>
      </html>
    `);
  }
});

// Debug endpoints for troubleshooting
router.get("/debug/active-switches", authenticateToken, (req, res) => {
  const userEmail = req.user.email;
  const switchData = activeDeadmanSwitches.get(userEmail);

  res.json({
    userEmail,
    hasActiveSwitch: !!switchData,
    switchData: switchData
      ? {
          lastActivity: switchData.lastActivity,
          nextCheckin: switchData.nextCheckinTime,
          hasCheckinTimer: !!switchData.checkinTimer,
          hasDeadmanTimer: !!switchData.deadmanTimer,
          sessionToken: switchData.sessionToken,
          emailCount: switchData.settings.emails
            ? switchData.settings.emails.length
            : 0,
        }
      : null,
    checkinTokens: Array.from(checkinTokens.entries()).filter(
      ([token, email]) => email === userEmail,
    ).length,
    userEmailsCount: (userEmails.get(userEmail) || []).length,
  });
});

router.get("/debug/activation-history", authenticateToken, (req, res) => {
  const userEmail = req.user.email;
  const history = deadmanActivationHistory.get(userEmail);

  res.json({
    userEmail,
    activationHistory: history || null,
  });
});

router.post("/debug/test-email", authenticateToken, async (req, res) => {
  try {
    const userEmail = req.user.email;
    const testResult = await emailService.testEmailConnection();

    if (testResult.success) {
      // Try sending a test check-in email
      const testToken = "test-token-" + Date.now();
      const emailSent = await emailService.sendCheckinEmail(
        userEmail,
        testToken,
      );

      res.json({
        emailService: testResult,
        testEmailSent: emailSent,
        message: emailSent
          ? "Test email sent successfully"
          : "Failed to send test email",
      });
    } else {
      res.json({
        emailService: testResult,
        testEmailSent: false,
        message: "Email service connection failed",
      });
    }
  } catch (error) {
    res.status(500).json({
      error: error.message,
      message: "Error testing email service",
    });
  }
});

module.exports = router;
